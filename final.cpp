// ------------------------------------
// Adam Beck
// Tested on Empress using g++
// ------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include<stdlib.h>
using namespace std;

// internally 9 is considered the empty square

// used for recording puzzle states
class state
{
public:
	int puzzle[9];
	int parent[9];
	int empty_square; // index of the empty square
	int g;
	int h;
	int f;

	state(int puzzle[9], int parent[9], int empty_square, int g, int h, int f)
	{
		for (int i = 0; i < 9; i++)
		{
			this->puzzle[i] = puzzle[i];
			this->parent[i] = parent[i];
		}

		this->empty_square = empty_square;
		this->g = g;
		this->h = h;
		this->f = f;
	}
};

vector<state> frontier;
vector<state> visited;
int inital[9]; // inital puzzle state generated by user, used as an end for tracePath()

// prints the puzzle on screen
void printPuzzle(int board[9])
{
	for (int i = 0; i < 9; i++)
	{
		if (board[i] == 9)
			cout << " ";
		else
			cout << board[i];

		if (i % 3 == 2)
			cout << endl;
	}
}

// true if the puzzle is the goal state
// false otherwise
bool isGoal(int board[9])
{
	for (int i = 0; i < 9; i++)
	{
		if (board[i] != i + 1)
			return false;
	}

	return true;
}

// returns the index of the empty square
int findEmpty(int board[9])
{
	int i = 0;
	while (i < 9)
	{
		if (board[i] == 9)
			return i;
		i++;
	}
}

// h = distance all pieces are from their goal spots
int getH(int board[9])
{
	int h = 0;
	int square, cur, goal;

	for (int i = 0; i < 9; i++)
	{
		square = board[i];

		// don't add anything to h if the square is in the correct spot
		if (square != i + 1)
		{
			cur = i; // index of square
			goal = square - 1; // index of where square is in goal state

			// calculate the distance the square is from its spot on the x-axis
			while (cur % 3 != goal % 3)
			{
				// see which direction the square needs to go
				if (cur % 3 > goal % 3)
					cur--; // move cur left
				else
					cur++; // move cur right
					
				h++;
			}

			// same for the y-axis
			while (cur / 3 != goal / 3)
			{
				// see which direction the square needs to go
				if (cur / 3 > goal / 3)
					cur -= 3; // move cur up
				else
					cur += 3; // move cur down

				h++;
			}
		}
	}

	return h;
}

// true if two puzzles match
// false otherwise
bool matches(int a1[9], int a2[9])
{
	for (int i = 0; i < 9; i++)
	{
		if (a1[i] != a2[i])
			return false;
	}

	return true;
}

// true if state is in visited vector
// false otherwise
bool inVisited(state next)
{
	for (int i = 0; i < visited.size(); i++)
		if (matches(visited[i].puzzle, next.puzzle))
			return true;

	return false;
}

// true if state is in frontier vector
// false otherwise
bool inFrontier(state next)
{
	for (int i = 0; i < frontier.size(); i++)
		if (matches(frontier[i].puzzle, next.puzzle))
			return true;

	return false;
}

// traces the path from the goal state to the inital state
void tracePath(state goal)
{
	printPuzzle(goal.puzzle);

	// end when state is the inital board
	if (matches(goal.puzzle, inital))
		return;

	int i = 0;
	// find the parent state in the visited vector
	while (i < visited.size() && !matches(visited[i].puzzle, goal.parent))
		i++;

	cout << "<<" << endl;
	tracePath(visited[i]); // print the board and find the parent's state (if applicable)
}

// try to add a state to the frontier state
void add(state next)
{
	cout << "Trying to add:" << endl;
	printPuzzle(next.puzzle);

	// end if state is the goal state
	if (isGoal(next.puzzle))
	{
		cout << ">>Reached:" << endl;
		tracePath(next);
		exit(0);
	}

	// don't add if the state has already been expanded
	if (inVisited(next))
		return;

	next.h = getH(next.puzzle); // calculate h
	next.f = next.g + next.h; // and f

	// don't add if the state is already in the frontier vector
	if (!inFrontier(next))
		frontier.push_back(next);
}

// expand the state into all the branches, add those to the frontier vector
void getBranches(state puzzle)
{
	state next = puzzle;
	
	// update g and parent for next
	puzzle.g = puzzle.g + 1;
	for (int i = 0; i < 9; i++)
		puzzle.parent[i] = puzzle.puzzle[i];


	next = puzzle;
	// try to move empty up
	if (puzzle.empty_square > 2)
	{
		// swap the empty square with the square above it
		next.puzzle[puzzle.empty_square] = next.puzzle[puzzle.empty_square - 3];
		next.puzzle[puzzle.empty_square - 3] = 9;
		next.empty_square = puzzle.empty_square - 3; // update the empty square index
		add(next); // attempt to add it to the frontier vector
	}

	next = puzzle;
	// try to move the empty square right
	if (puzzle.empty_square % 3 != 2)
	{
		// swap the empty square with the square to the right
		next.puzzle[puzzle.empty_square] = next.puzzle[puzzle.empty_square + 1];
		next.puzzle[puzzle.empty_square + 1] = 9;
		next.empty_square = puzzle.empty_square + 1; // update the empty square index
		add(next); // attempt to add it to the frontier vector
	}

	next = puzzle;
	// try to move the empty square down
	if (puzzle.empty_square < 6)
	{
		// swap the empty square with the square below it
		next.puzzle[puzzle.empty_square] = next.puzzle[puzzle.empty_square + 3];
		next.puzzle[puzzle.empty_square + 3] = 9;
		next.empty_square = puzzle.empty_square + 3; // update the empty square index
		add(next); // attempt to add it to the frontier vector
	}

	next = puzzle;
	// try to move the empty square left
	if (puzzle.empty_square % 3 != 0)
	{
		// swap the empty square with the square to the left
		next.puzzle[puzzle.empty_square] = next.puzzle[puzzle.empty_square - 1];
		next.puzzle[puzzle.empty_square - 1] = 9;
		next.empty_square = puzzle.empty_square - 1; // update the empty square index
		add(next); // attempt to add it to the frontier vector
	}
}

// remove the given state from the frontier vector
void remove(state puzzle)
{
	vector<state> newfrontier;
	for (int i = 0; i < frontier.size(); i++)
	{
		if (!matches(frontier[i].puzzle, puzzle.puzzle))
		{
			newfrontier.push_back(frontier[i]);
		}
	}

	frontier = newfrontier;
}

// prints the entire frontier vector (board, g, h, f)
void printFrontier()
{
	for (int i = 0; i < frontier.size(); i++)
	{
		printPuzzle(frontier[i].puzzle);
		cout << "g = " << frontier[i].g << " ";
		cout << "h = " << frontier[i].h << " ";
		cout << "f = " << frontier[i].f << endl;
	}
}

// return the frontier with the lowest f value
state bestFrontier()
{
	state best = frontier[0];
	for (int i = 1; i < frontier.size(); i++)
	{
		if (frontier[i].f < best.f)
		{
			best = frontier[i];
		}
	}

	return best;
}

int main()
{
	string end[9] = { "Top Left", "Top Middle", "Top Right", "Middle Left", "Middle Middle", "Middle Right", "Bottom Left", "Bottom Middle", "Bottom Right"}; // used for output
	cout << "Create the puzzle..." << endl;
	// get inital board state from user
	for (int i = 0; i < 9; i++)
	{
		cout << "Choose a number for the " << end[i] << " square: ";
		cin >> inital[i];
	}

	int parent[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // empty parent
	int h = getH(inital); // get h value of inital board
	state puzzle(inital, parent, findEmpty(inital), 0, getH(inital), 0 + h); // create state
	frontier.push_back(puzzle);
	int limit = 0;

	// end when goal state is found or puzzle cannot be solved
	while (limit < 500)
	{
		// take off frontier vector and add to visited vector
		visited.push_back(puzzle);
		remove(puzzle);

		// expand the state into its branches, add those to frontier
		cout << ">>>Expand:" << endl;
		printPuzzle(puzzle.puzzle);
		getBranches(puzzle);

		// print all the frontier nodes
		cout << "Frontier is:" << endl;
		printFrontier();

		puzzle = bestFrontier(); // pick the best state out of frontier
		limit++;
	}

	cout << "Puzzle cannot be solved..." << endl << "Exiting program.";
}